apiVersion: camel.apache.org/v1alpha1
kind: Kamelet
metadata:
  name: k-dynamic-publisher
  labels:
    camel.apache.org/kamelet.type: "sink"
spec:
  definition:
    title: "K-Dynamic Publisher"
    description: "Dynamic publisher that routes messages to different transport types based on RefFlowData configuration"
    type: object
    properties:
      header-name:
        title: "Header name"
        description: "The header name containing the RefFlowData"
        type: string
        default: "RefFlowData"
  dependencies:
    - "camel:kamelet"
    - "camel:log"
    - "camel:jsonpath"
    - "camel:groovy"
  template:
    from:
      uri: "kamelet:source"
      steps:
        - log:
            message: "K-Dynamic-Publisher: Starting dynamic transport routing"
        
        - setProperty:
            name: "originalXmlBody"
            simple: "${body}"
        
        - setProperty:
            name: "refFlowDataJson"
            simple: "${header[RefFlowData]}"
        
        # Initialize counters
        - setProperty:
            name: "successCount"
            constant: "0"
        
        - setProperty:
            name: "failureCount"
            constant: "0"
        
        - choice:
            when:
              - expression:
                  simple: "${exchangeProperty.refFlowDataJson} != null"
                steps:
                  - log:
                      message: "K-Dynamic-Publisher: RefFlowData found"
                  
                  # Step 1: Get List of partnerOut enabled Y
                  - script:
                      groovy: |
                        def refFlowJson = exchange.properties['refFlowDataJson']
                        
                        // Extract flow info using basic string manipulation
                        def flowIdMatch = (refFlowJson =~ /"FlowID":\s*"([^"]+)"/)
                        def flowCodeMatch = (refFlowJson =~ /"flowCode":\s*"([^"]+)"/)
                        
                        def flowId = flowIdMatch.find() ? flowIdMatch.group(1) : "unknown"
                        def flowCode = flowCodeMatch.find() ? flowCodeMatch.group(1) : "unknown"
                        
                        exchange.properties['flowId'] = flowId
                        exchange.properties['flowCode'] = flowCode
                        
                        // Extract original partnerOut block for logging
                        def partnerOutMatch = (refFlowJson =~ /(?s)"partnerOut":\s*(\[.*?\])/)
                        def originalPartnerOut = partnerOutMatch.find() ? partnerOutMatch.group(1) : "[]"
                        exchange.properties['originalPartnerOut'] = originalPartnerOut
                        
                        // Step 1: Get List of partnerOut enabled Y using enhanced regex with transport details
                        def enabledPartners = []
                        
                        // Match each complete partner object individually
                        def partnerObjectPattern = /\{\s*"partnerCode":\s*"([^"]+)"[^}]*?"enabled":\s*"([^"]+)"[^}]*?"transport":\s*\{\s*"type":\s*"([^"]+)"[^}]*?\}\s*\}/
                        def matcher = refFlowJson =~ partnerObjectPattern
                        
                        while (matcher.find()) {
                          def partnerCode = matcher.group(1)
                          def enabled = matcher.group(2)
                          def transportType = matcher.group(3)
                          
                          println "Debug: Found partner ${partnerCode}, enabled=${enabled}, transport=${transportType}"
                          
                          // Only include if enabled = "Y"
                          if (enabled == "Y") {
                            def endpoint = ""
                            def queueName = "${partnerCode}.output.queue"
                            
                            enabledPartners.add([
                              partnerCode: partnerCode,
                              transportType: transportType,
                              endpoint: endpoint,
                              queueName: queueName
                            ])
                            
                            println "Found enabled partner: ${partnerCode} - Transport: ${transportType} - Endpoint: ${endpoint} - Queue: ${queueName}"
                          } else {
                            println "Skipping disabled partner: ${partnerCode} - Transport: ${transportType}"
                          }
                        }
                        
                        exchange.properties['enabledPartners'] = enabledPartners
                        exchange.properties['totalPartners'] = enabledPartners.size()
                        
                        println "Found ${enabledPartners.size()} enabled partners for processing"
                  
                  - log:
                      message: "Found ${exchangeProperty.totalPartners} enabled partners for multicast processing: ${exchangeProperty.enabledPartners}. Original partnerOut: ${exchangeProperty.originalPartnerOut}"
                  
                  # Step 2: Process each enabled partner sequentially
                  - choice:
                      when:
                        - simple: "${exchangeProperty.totalPartners} > 0"
                          steps:
                            - script:
                                groovy: |
                                  def enabledPartners = exchange.properties['enabledPartners']
                                  exchange.properties['successCount'] = 0
                                  exchange.properties['failureCount'] = 0
                                  exchange.properties['currentPartnerIndex'] = 0
                                  
                                  println "Starting to process ${enabledPartners.size()} partners"
                            
                            - loop:
                                expression:
                                  simple: "${exchangeProperty.totalPartners}"
                                steps:
                                  # Set current partner context
                                  - script:
                                      groovy: |
                                        def enabledPartners = exchange.properties['enabledPartners'] as List
                                        def partnerIndex = exchange.properties['currentPartnerIndex'] as Integer ?: 0
                                        
                                        println "Debug: Partner index: ${partnerIndex}, Partners list size: ${enabledPartners?.size()}"
                                        
                                        if (enabledPartners != null && partnerIndex >= 0 && partnerIndex < enabledPartners.size()) {
                                          def partner = enabledPartners.get(partnerIndex)
                                          
                                          exchange.properties['currentPartnerCode'] = partner?.partnerCode ?: "unknown"
                                          exchange.properties['currentTransportType'] = partner?.transportType ?: "unknown"
                                          exchange.properties['currentEndpoint'] = partner?.endpoint ?: ""
                                          exchange.properties['currentQueueName'] = partner?.queueName ?: "unknown.queue"
                                          
                                          println "Processing partner ${partnerIndex + 1}/${enabledPartners.size()}: ${partner.partnerCode} with transport: ${partner.transportType}"
                                          
                                          // Increment index for next iteration
                                          exchange.properties['currentPartnerIndex'] = partnerIndex + 1
                                        } else {
                                          exchange.properties['currentPartnerCode'] = "error"
                                          exchange.properties['currentTransportType'] = "error"
                                          exchange.properties['currentEndpoint'] = ""
                                          exchange.properties['currentQueueName'] = "error.queue"
                                          println "Error: Invalid partner index ${partnerIndex} or empty partners list (size: ${enabledPartners?.size()})"
                                        }
                                  
                                  # Step 3: Switch case for transport type with actual kamelet calls
                                  - choice:
                                      when:
                                        - simple: "${exchangeProperty.currentTransportType} == 'CFT'"
                                          steps:
                                            - log:
                                                message: "Calling k-cft-publisher for partner: ${exchangeProperty.currentPartnerCode}"
                                            - doTry:
                                                steps:
                                                  - setHeader:
                                                      name: "PartnerCode"
                                                      simple: "${exchangeProperty.currentPartnerCode}"
                                                  - toD: "kamelet:k-cft-publisher?directoryPath=/nas/outgoing/cft&flowCode=${exchangeProperty.flowCode}&flowId=${exchangeProperty.flowId}&dataSource=dataSource"
                                                  - script:
                                                      groovy: |
                                                        def successCount = exchange.properties['successCount'] as Integer ?: 0
                                                        exchange.properties['successCount'] = successCount + 1
                                                        println "CFT Publisher SUCCESS for ${exchange.properties['currentPartnerCode']}"
                                                doCatch:
                                                  - exception: "java.lang.Exception"
                                                    steps:
                                                      - script:
                                                          groovy: |
                                                            def failureCount = exchange.properties['failureCount'] as Integer ?: 0
                                                            exchange.properties['failureCount'] = failureCount + 1
                                                            println "CFT Publisher FAILED for ${exchange.properties['currentPartnerCode']}: ${exception.message}"
                                        - simple: "${exchangeProperty.currentTransportType} == 'MQ' || ${exchangeProperty.currentTransportType} == 'MQS'"
                                          steps:
                                            - log:
                                                message: "Calling k-mq-publisher for partner: ${exchangeProperty.currentPartnerCode}"
                                            - doTry:
                                                steps:
                                                  - setHeader:
                                                      name: "PartnerCode"
                                                      simple: "${exchangeProperty.currentPartnerCode}"
                                                  - toD: "kamelet:k-mq-publisher?mqFileName=${exchangeProperty.currentQueueName}&connectionFactory=jmsConnectionFactory&flowCode=${exchangeProperty.flowCode}&flowId=${exchangeProperty.flowId}&dataSource=dataSource"
                                                  - script:
                                                      groovy: |
                                                        def successCount = exchange.properties['successCount'] as Integer ?: 0
                                                        exchange.properties['successCount'] = successCount + 1
                                                        println "MQ/MQS Publisher SUCCESS for ${exchange.properties['currentPartnerCode']}"
                                                doCatch:
                                                  - exception: "java.lang.Exception"
                                                    steps:
                                                      - script:
                                                          groovy: |
                                                            def failureCount = exchange.properties['failureCount'] as Integer ?: 0
                                                            exchange.properties['failureCount'] = failureCount + 1
                                                            println "MQ/MQS Publisher FAILED for ${exchange.properties['currentPartnerCode']}: ${exception.message}"
                                        - simple: "${exchangeProperty.currentTransportType} == 'HTTP'"
                                          steps:
                                            - log:
                                                message: "Calling k-http-publisher for partner: ${exchangeProperty.currentPartnerCode}"
                                            - doTry:
                                                steps:
                                                  - setHeader:
                                                      name: "PartnerCode"
                                                      simple: "${exchangeProperty.currentPartnerCode}"
                                                  - toD: "kamelet:k-http-publisher?httpUrl=${exchangeProperty.currentEndpoint}&flowCode=${exchangeProperty.flowCode}&flowId=${exchangeProperty.flowId}&dataSource=dataSource"
                                                  - script:
                                                      groovy: |
                                                        def successCount = exchange.properties['successCount'] as Integer ?: 0
                                                        exchange.properties['successCount'] = successCount + 1
                                                        println "HTTP Publisher SUCCESS for ${exchange.properties['currentPartnerCode']}"
                                                doCatch:
                                                  - exception: "java.lang.Exception"
                                                    steps:
                                                      - script:
                                                          groovy: |
                                                            def failureCount = exchange.properties['failureCount'] as Integer ?: 0
                                                            exchange.properties['failureCount'] = failureCount + 1
                                                            println "HTTP Publisher FAILED for ${exchange.properties['currentPartnerCode']}: ${exception.message}"
                                        - simple: "${exchangeProperty.currentTransportType} == 'KAFKA'"
                                          steps:
                                            - log:
                                                message: "Calling k-kafka-publisher for partner: ${exchangeProperty.currentPartnerCode}"
                                            - doTry:
                                                steps:
                                                  - setHeader:
                                                      name: "PartnerCode"
                                                      simple: "${exchangeProperty.currentPartnerCode}"
                                                  - toD: "kamelet:k-kafka-publisher?kafkaTopicName=${exchangeProperty.currentPartnerCode}-topic&brokers=kafka:29092&key=${exchangeProperty.currentPartnerCode}"
                                                  - script:
                                                      groovy: |
                                                        def successCount = exchange.properties['successCount'] as Integer ?: 0
                                                        exchange.properties['successCount'] = successCount + 1
                                                        println "Kafka Publisher SUCCESS for ${exchange.properties['currentPartnerCode']}"
                                                doCatch:
                                                  - exception: "java.lang.Exception"
                                                    steps:
                                                      - script:
                                                          groovy: |
                                                            def failureCount = exchange.properties['failureCount'] as Integer ?: 0
                                                            exchange.properties['failureCount'] = failureCount + 1
                                                            println "Kafka Publisher FAILED for ${exchange.properties['currentPartnerCode']}: ${exception.message}"
                                      otherwise:
                                        steps:
                                          - script:
                                              groovy: |
                                                def failureCount = exchange.properties['failureCount'] as Integer ?: 0
                                                exchange.properties['failureCount'] = failureCount + 1
                                                def partnerCode = exchange.properties['currentPartnerCode'] ?: "unknown"
                                                def transportType = exchange.properties['currentTransportType'] ?: "unknown"
                                                println "Unsupported transport FAILED for partner: ${partnerCode}, transport: ${transportType}"
                            # Log final results
                            - log:
                                message: "PROCESSING COMPLETED - Total Partners: ${exchangeProperty.totalPartners}, Successful Calls: ${exchangeProperty.successCount}, Failed Calls: ${exchangeProperty.failureCount}"
                      otherwise:
                        steps:
                          - log:
                              message: "No enabled partners found for processing"
            otherwise:
                steps:
                  - log:
                      message: "K-Dynamic-Publisher: No RefFlowData found in header RefFlowData"
                      
        # Restore original message body
        - setBody:
            simple: "${exchangeProperty.originalXmlBody}"
        
        - log:
            message: "K-Dynamic-Publisher: Completed"
        - to: "kamelet:sink"