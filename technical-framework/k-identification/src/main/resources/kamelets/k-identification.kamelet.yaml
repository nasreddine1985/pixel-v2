apiVersion: camel.apache.org/v1alpha1
kind: Kamelet
metadata:
  name: k-identification
  annotations:
    camel.apache.org/kamelet.support.level: "Stable"
    camel.apache.org/catalog.version: "1.0.1-SNAPSHOT"
    camel.apache.org/provider: "PIXEL-V2"
  labels:
    camel.apache.org/kamelet.type: "action"
spec:
  definition:
    title: "PIXEL-V2 Identification Kamelet"
    description: |-
      Spring cache-based reference data identification and caching kamelet for payment processing.
      Uses Spring Boot application's memory cache instead of external Redis.
      Fetches flow configuration from Spring memory cache or referential service with automatic cache population.
    required:
      - flowCode
    type: object
    properties:
      flowCode:
        title: Flow Code
        description: The flow code to identify and retrieve configuration for
        type: string
      referentialServiceUrl:
        title: Referential Service URL
        description: Base URL of the referential service for flow configuration retrieval
        type: string
      kafkaBrokers:
        title: Kafka Brokers
        description: Kafka broker URLs for cache refresh messaging
        type: string
      cacheTtl:
        title: Cache TTL
        description: Cache time-to-live in seconds (for future use with TTL-enabled caches)
        type: integer
        default: 3600
      springCacheName:
        title: Spring Cache Name
        description: Name of the Spring cache to use for storing flow configurations
        type: string
        default: "flowConfigCache"
  dependencies:
    - "camel:kamelet"
    - "camel:log"
    - "camel:http"
    - "camel:jackson"
    - "camel:kafka"
    - "camel:spring-boot-starter"
    - "camel:groovy"
  template:
    from:
      uri: "kamelet:source"
      steps:
        # Store original message body for preservation and set cache configuration
        - script:
            groovy: |
              exchange.in.headers['OriginalBody'] = exchange.in.body
              exchange.in.headers['CacheKey'] = 'flow_config_{{flowCode}}'
              exchange.in.headers['SpringCacheName'] = '{{springCacheName}}'
              exchange.in.headers['SpringCacheKey'] = '{{flowCode}}'
        - setHeader:
            name: "ProcessingTimestamp"
            simple: "${date:now:yyyy-MM-dd'T'HH:mm:ss.SSSSSS}"
        - setHeader:
            name: "ContextId"
            simple: "identification-${uuid}"
        - toD:
            uri: "kamelet:k-log-events?kafkaTopicName=${headers.KafkaLogTopicName}&brokers=${headers.Brokers}&flowId=${header.FlowOccurId}&flowCode={{flowCode}}&logMessageTxt=Start identification - flowOccurId: ${header.FlowOccurId}, FlowCode: ${header.FlowCode}&level=INFO&processingTimestamp=${header.ProcessingTimestamp}&contextId=${header.ContextId}&component=K-IDENTIFICATION"
            pattern: "InOnly"

        # Try to get from Spring cache using custom processor
        - to: "bean:springCacheProcessorInterne?method=getCachedValue"
        
        # Choose based on cache result
        - choice:
            when:
              - simple: "${body} == null"
                steps:
                  - log: 
                      message: "Spring Cache MISS: Fetching flow config for ${header.SpringCacheKey} from referential service"
                      loggingLevel: DEBUG
                  # Fetch from referential service
                  - doTry:
                      steps:
                        
                        
                        # Save current headers before removing them
                        - script:
                            groovy: |
                              def savedHeaders = [:]
                              exchange.in.headers.each { key, value ->
                                  savedHeaders[key] = value
                              }
                              exchange.setProperty('savedHeaders', savedHeaders)
                        # Remove all headers for clean HTTP call
                        - removeHeaders: "*"
                        - setHeader:
                            name: CamelHttpMethod
                            constant: "GET"
                        - setHeader:
                            name: Content-Type
                            constant: "application/json"
                        
                        - toD: "{{referentialServiceUrl}}/api/referential/flows/{{flowCode}}/complete?bridgeEndpoint=true"
                        # Restore saved headers after HTTP call
                        - script:
                            groovy: |
                              def savedHeaders = exchange.getProperty('savedHeaders', Map.class)
                              if (savedHeaders != null) {
                                savedHeaders.each { key, value ->
                                  exchange.in.setHeader(key, value)
                                }
                              }
                              exchange.removeProperty('savedHeaders')
                        
                        - convertBodyTo: "java.lang.String"
                        - log: 
                            message: "Successfully retrieved flow config for ${header.FlowCode} from referential service"
                            loggingLevel: INFO
                        - script:
                            groovy: |
                              exchange.in.headers['RefFlowData'] = exchange.in.body
                              exchange.in.headers['SpringCacheValue'] = exchange.in.body
                        - setBody:
                            simple: "${header.OriginalBody}"
                        
                        # Cache the result in Spring cache
                        - to: "bean:springCacheProcessorInterne?method=putCachedValue"
                      doCatch:
                        - exception: "java.lang.Exception"
                          steps:
                            - log: 
                                message: "Failed to retrieve flow config for ${header.SpringCacheKey} from referential service: ${exception.message}"
                                loggingLevel: ERROR
                            - setHeader:
                                name: "RefFlowData"
                                simple: '{"error":"referential_service_unavailable","flowCode":"${header.SpringCacheKey}"}'
                            - setBody:
                                simple: "${header.OriginalBody}"
            otherwise:
              steps:
                - log: 
                    message: "Spring Cache HIT: Using cached flow config for ${header.SpringCacheKey}"
                    loggingLevel: DEBUG
                
                - setHeader:
                    name: RefFlowData
                    simple: "${body}"
        
        # Restore original message body
        - setBody:
            simple: "${header.OriginalBody}"
        - removeHeader: "OriginalBody"
        
        # Log event after identification
        - setHeader:
            name: "ProcessingTimestamp"
            simple: "${date:now:yyyy-MM-dd'T'HH:mm:ss.SSSSSS}"
        - toD:
            uri: "kamelet:k-log-events?kafkaTopicName=${headers.KafkaLogTopicName}&brokers=${headers.Brokers}&flowId=${header.FlowOccurId}&flowCode=${header.FlowCode}&logMessageTxt=End identification - flowOccurId: ${header.FlowOccurId}, FlowCode: ${header.FlowCode}&level=INFO&processingTimestamp=${header.ProcessingTimestamp}&contextId=${header.ContextId}&component=K-IDENTIFICATION"
            pattern: "InOnly"
        
        # Send to sink
        - to: "kamelet:sink"