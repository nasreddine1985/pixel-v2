# ===================================================================
# INTELLIGENT ROUTING CONFIGURATION
# ===================================================================
# This configuration implements smart routing based on message source:
# - CFT messages (files) → Kafka topics (batch processing)
# - HTTP/MQ messages → Processing module (synchronous processing)
# 
# Processing Module Integration - Message Metadata Enrichment Processor
- beans:
    - name: enrichMessageWithMetadata
      type: "#class:com.pixel.v2.ingestion.processor.MessageMetadataEnrichmentProcessor"

# ===================================================================
# MAIN ORCHESTRATOR - Supports Intelligent Routing After Idempotence
# ===================================================================
- route:
    id: payment-ingestion-orchestrator
    from:
      uri: direct:payment-ingestion
      steps:
        - log:
            message: "Starting payment ingestion orchestration for message: ${body}"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Starting payment ingestion orchestration for message ID: ${header.MessageId}, Receipt Channel: ${header.ReceiptChannel}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: IngestionStartTime
            simple: "${date:now:yyyy-MM-dd HH:mm:ss}"
        - setHeader:
            name: ProcessingStage
            constant: INGESTION_START
        - to:
            uri: direct:database-persistence
        - to:
            uri: direct:reference-enrichment
        - to:
            uri: direct:enriched-data-persistence
        - to:
            uri: direct:validation
        - to:
            uri: direct:idempotence-check
        - choice:
            when:
              - simple: "${header.CanProcess} == true"
                steps:
                  - log:
                      message: "Routing message based on receipt channel: ${header.ReceiptChannel}"
                  - setHeader:
                      name: "LogLevel"
                      constant: "INFO"
                  - setHeader:
                      name: "LogSource"
                      constant: "ingestion"
                  - setHeader:
                      name: "LogCategory"
                      constant: "ROUTE"
                  - setHeader:
                      name: "CorrelationId"
                      simple: "${header.MessageId}"
                  - setBody:
                      simple: "Routing message based on receipt channel: ${header.ReceiptChannel} for message ID: ${header.MessageId}"
                  - to: "kamelet:k-log-tx"
                  - choice:
                      when:
                        - simple: "${header.ReceiptChannel} == 'CFT'"
                          steps:
                            - log:
                                message: "[SMART-ROUTING] CFT message - routing to Kafka for batch processing"
                            - setHeader:
                                name: "LogLevel"
                                constant: "INFO"
                            - setHeader:
                                name: "LogSource"
                                constant: "ingestion"
                            - setHeader:
                                name: "LogCategory"
                                constant: "ROUTE"
                            - setHeader:
                                name: "CorrelationId"
                                simple: "${header.MessageId}"
                            - setBody:
                                simple: "[SMART-ROUTING] CFT message routing to Kafka for batch processing - Message ID: ${header.MessageId}"
                            - to: "kamelet:k-log-tx"
                            - to:
                                uri: direct:kafka-publisher
                      otherwise:
                        steps:
                          - log:
                              message: "[SMART-ROUTING] HTTP/MQ message - routing to processing module for real-time processing"
                          - setHeader:
                              name: "LogLevel"
                              constant: "INFO"
                          - setHeader:
                              name: "LogSource"
                              constant: "ingestion"
                          - setHeader:
                              name: "LogCategory"
                              constant: "ROUTE"
                          - setHeader:
                              name: "CorrelationId"
                              simple: "${header.MessageId}"
                          - setBody:
                              simple: "[SMART-ROUTING] HTTP/MQ message routing to processing module for real-time processing - Message ID: ${header.MessageId}, Channel: ${header.ReceiptChannel}"
                          - to: "kamelet:k-log-tx"
                          - to:
                              uri: direct:processing-publisher
            otherwise:
              steps:
                - to:
                    uri: direct:rejection-handler

# ===================================================================
# MESSAGE RECEIPT ROUTES - Enhanced with Channel Identification
# ===================================================================
# Each route sets ReceiptChannel header for intelligent routing:
# - MQ: Sets ReceiptChannel="MQ" → Routes to Processing Module
# - HTTP: Sets ReceiptChannel="HTTP" → Routes to Processing Module  
# - CFT: Sets ReceiptChannel="CFT" → Routes to Kafka Topics
- route:
    id: mq-receipt-route
    from:
      uri: kamelet:k-mq-message-receiver?queueName={{ingestion.mq.input.queue:PAYMENT_INPUT}}&host={{ingestion.mq.host:localhost}}&port={{ingestion.mq.port:1414}}&queueManager={{ingestion.mq.queue.manager:QM1}}&channel={{ingestion.mq.channel:DEV.ADMIN.SVRCONN}}&username={{ingestion.mq.username:admin}}&password={{ingestion.mq.password:admin}}&concurrentConsumers={{ingestion.mq.concurrent-consumers:5}}&maxConcurrentConsumers={{ingestion.mq.max-concurrent-consumers:10}}
      steps:
        - log:
            message: "[MQ-RECEIPT] Message received from k-mq-message-receiver kamelet"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "mq-receipt"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "[MQ-RECEIPT] Message received from k-mq-message-receiver kamelet - Message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ReceiptChannel
            constant: "MQ"
        - setHeader:
            name: MessageSource
            constant: "MQ_SERIES"
        - to:
            uri: direct:payment-ingestion

- route:
    id: http-receipt-route
    from:
      uri: kamelet:k-http-message-receiver?port={{server.port:8080}}&contextPath={{server.servlet.context-path:/ingestion}}/api/v1/payments
      steps:
        - log:
            message: "[HTTP-RECEIPT] Message received from k-http-message-receiver kamelet"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "http-receipt"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "[HTTP-RECEIPT] Message received from k-http-message-receiver kamelet - Message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ReceiptChannel
            constant: "HTTP"
        - setHeader:
            name: MessageSource
            constant: "HTTP_API"
        - to:
            uri: direct:payment-ingestion

- route:
    id: file-receipt-route
    from:
      uri: kamelet:k-cft-data-receiver?directoryPath={{ingestion.file.input.directory:/tmp/payments-in}}&filePattern={{ingestion.file.pattern:.*\\.xml}}&processedDirectory={{ingestion.file.processed.directory:/tmp/payments-processed}}&errorDirectory={{ingestion.file.error.directory:/tmp/payments-error}}&delay={{ingestion.file.delay:5000}}
      steps:
        - log:
            message: "[CFT-RECEIPT] Message received from k-cft-data-receiver kamelet"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "cft-receipt"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "[CFT-RECEIPT] Message received from k-cft-data-receiver kamelet - File: ${header.CamelFileName}, Message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ReceiptChannel
            constant: "CFT"
        - setHeader:
            name: MessageSource
            constant: "CFT_FILE"
        - to:
            uri: direct:payment-ingestion

# Database Persistence Step (First step after message receipt)
- route:
    id: database-persistence
    from:
      uri: direct:database-persistence
      steps:
        - log:
            message: "Persisting message to database via k-db-tx"
            level: INFO
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Persisting message to database via k-db-tx for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
            
        - setHeader:
            name: "ProcessingStage"
            constant: "DATABASE_PERSISTENCE"
            
        - to:
            uri: kamelet:k-db-tx
        - choice:
            when:
              - simple: "${header.persistenceStatus} == 'SUCCESS'"
                steps:
                  - log:
                      message: "Message successfully persisted to database with ID: ${header.persistedMessageId}"
                  - setHeader:
                      name: "LogLevel"
                      constant: "INFO"
                  - setHeader:
                      name: "LogSource"
                      constant: "ingestion"
                  - setHeader:
                      name: "LogCategory"
                      constant: "BUSINESS"
                  - setHeader:
                      name: "CorrelationId"
                      simple: "${header.MessageId}"
                  - setBody:
                      simple: "Message successfully persisted to database with ID: ${header.persistedMessageId} for message: ${header.MessageId}"
                  - to: "kamelet:k-log-tx"
                  - setHeader:
                      name: MessagePersisted
                      constant: true
            otherwise:
              steps:
                - log:
                    message: "Database persistence failed: ${header.persistenceError}"
                - setHeader:
                    name: "LogLevel"
                    constant: "ERROR"
                - setHeader:
                    name: "LogSource"
                    constant: "ingestion"
                - setHeader:
                    name: "LogCategory"
                    constant: "ERROR"
                - setHeader:
                    name: "CorrelationId"
                    simple: "${header.MessageId}"
                - setBody:
                    simple: "Database persistence failed: ${header.persistenceError} for message: ${header.MessageId}"
                - to: "kamelet:k-log-tx"
                - setHeader:
                    name: MessagePersisted
                    constant: false
                - setHeader:
                    name: RejectionReason
                    constant: DATABASE_PERSISTENCE_FAILED
                - to:
                    uri: direct:error-handler
                - stop: {}

- route:
    id: reference-enrichment
    from:
      uri: direct:reference-enrichment
      steps:
        - log:
            message: "Enriching message with reference data"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Enriching message with reference data for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: REFERENCE_ENRICHMENT
        - to:
            uri: kamelet:k-referentiel-data-loader
        - log:
            message: "Reference data enrichment completed"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Reference data enrichment completed for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"

# Enriched Data Persistence Step (After reference enrichment)
- route:
    id: enriched-data-persistence
    from:
      uri: direct:enriched-data-persistence
      steps:
        - log:
            message: "Persisting enriched message data to database"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Persisting enriched message data to database for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: ENRICHED_DATA_PERSISTENCE
        - setHeader:
            name: PersistenceType
            constant: ENRICHED
        - to:
            uri: kamelet:k-db-tx
        - choice:
            when:
              - simple: "${header.persistenceStatus} == 'SUCCESS'"
                steps:
                  - log:
                      message: "Enriched message data successfully persisted to database with ID: ${header.persistedMessageId}"
                  - setHeader:
                      name: EnrichedDataPersisted
                      constant: true
            otherwise:
              steps:
                - log:
                    message: "Enriched data persistence failed: ${header.persistenceError}"
                - setHeader:
                    name: EnrichedDataPersisted
                    constant: false
                - setHeader:
                    name: RejectionReason
                    constant: ENRICHED_DATA_PERSISTENCE_FAILED
                - to:
                    uri: direct:error-handler
                - stop: {}

- route:
    id: validation-step
    from:
      uri: direct:validation
      steps:
        - log:
            message: "Starting message validation"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Starting message validation for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: VALIDATION
        - to:
            uri: kamelet:k-ingestion-technical-validation
        - choice:
            when:
              - simple: "${header.IsValid} == true"
                steps:
                  - log:
                      message: "Message validation passed"
                  - setHeader:
                      name: "LogLevel"
                      constant: "INFO"
                  - setHeader:
                      name: "LogSource"
                      constant: "ingestion"
                  - setHeader:
                      name: "LogCategory"
                      constant: "BUSINESS"
                  - setHeader:
                      name: "CorrelationId"
                      simple: "${header.MessageId}"
                  - setBody:
                      simple: "Message validation passed for message ID: ${header.MessageId}"
                  - to: "kamelet:k-log-tx"
            otherwise:
              steps:
                - log:
                    message: "Message validation failed: ${header.ValidationResult}"
                - setHeader:
                    name: "LogLevel"
                    constant: "ERROR"
                - setHeader:
                    name: "LogSource"
                    constant: "ingestion"
                - setHeader:
                    name: "LogCategory"
                    constant: "ERROR"
                - setHeader:
                    name: "CorrelationId"
                    simple: "${header.MessageId}"
                - setBody:
                    simple: "Message validation failed: ${header.ValidationResult} for message ID: ${header.MessageId}"
                - to: "kamelet:k-log-tx"
                - setHeader:
                    name: RejectionReason
                    constant: VALIDATION_FAILED

- route:
    id: idempotence-check
    from:
      uri: direct:idempotence-check
      steps:
        - log:
            message: "Starting idempotence check"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "ingestion"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Starting idempotence check for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: IDEMPOTENCE
        - to:
            uri: kamelet:k-payment-idempotence-helper?messageId=${header.MessageId}&checkMode=PROCESS
        - choice:
            when:
              - simple: "${header.IsDuplicate} == true"
                steps:
                  - log:
                      message: "Duplicate message detected, checking action"
                  - setHeader:
                      name: "LogLevel"
                      constant: "WARN"
                  - setHeader:
                      name: "LogSource"
                      constant: "ingestion"
                  - setHeader:
                      name: "LogCategory"
                      constant: "BUSINESS"
                  - setHeader:
                      name: "CorrelationId"
                      simple: "${header.MessageId}"
                  - setBody:
                      simple: "Duplicate message detected, checking action for message ID: ${header.MessageId}"
                  - to: "kamelet:k-log-tx"
                  - choice:
                      when:
                        - simple: "${header.ShouldReject} == true"
                          steps:
                            - setHeader:
                                name: RejectionReason
                                constant: DUPLICATE_MESSAGE
                            - setHeader:
                                name: CanProcess
                                constant: false
                        - simple: "${header.ShouldIgnore} == true"
                          steps:
                            - log:
                                message: "Ignoring duplicate message as per configuration"
                            - setHeader:
                                name: LogLevel
                                constant: "WARN"
                            - setHeader:
                                name: LogSource
                                constant: "IDEMPOTENCE_CHECK"
                            - setHeader:
                                name: LogCategory
                                constant: "BUSINESS"
                            - setHeader:
                                name: CorrelationId
                                simple: "${header.MessageId}"
                            - setBody:
                                simple: "Duplicate message ignored per configuration: MessageId=${header.MessageId}, ShouldIgnore=${header.ShouldIgnore}"
                            - to: kamelet:k-log-tx
                            - setHeader:
                                name: CanProcess
                                constant: false
                      otherwise:
                        steps:
                          - log:
                              message: "Processing duplicate with warning"
                          - setHeader:
                              name: LogLevel
                              constant: "WARN"
                          - setHeader:
                              name: LogSource
                              constant: "IDEMPOTENCE_CHECK"
                          - setHeader:
                              name: LogCategory
                              constant: "BUSINESS"
                          - setHeader:
                              name: CorrelationId
                              simple: "${header.MessageId}"
                          - setBody:
                              simple: "Processing duplicate message with warning: MessageId=${header.MessageId}"
                          - to: kamelet:k-log-tx
            otherwise:
              steps:
                - log:
                    message: "Message idempotence check passed"
                - setHeader:
                    name: LogLevel
                    constant: "INFO"
                - setHeader:
                    name: LogSource
                    constant: "IDEMPOTENCE_CHECK"
                - setHeader:
                    name: LogCategory
                    constant: "BUSINESS"
                - setHeader:
                    name: CorrelationId
                    simple: "${header.MessageId}"
                - setBody:
                    simple: "Idempotence check passed successfully: MessageId=${header.MessageId}"
                - to: kamelet:k-log-tx

- route:
    id: kafka-publisher
    from:
      uri: direct:kafka-publisher
      steps:
        - log:
            message: "[KAFKA-ROUTE] Publishing message to Kafka for batch processing"
        - setHeader:
            name: ProcessingStage
            constant: KAFKA_PUBLISH
        - setHeader:
            name: PublishTimestamp
            simple: "${date:now:yyyy-MM-dd HH:mm:ss}"
        - setHeader:
            name: RoutingDestination
            constant: "kafka"
        - choice:
            when:
              - simple: "${header.ExpectedMessageType} == 'pacs.008'"
                steps:
                  - setHeader:
                      name: KafkaTopic
                      simple: "{{ingestion.kafka.topic.pacs008:payments-pacs008}}"
              - simple: "${header.ExpectedMessageType} == 'pacs.009'"
                steps:
                  - setHeader:
                      name: KafkaTopic
                      simple: "{{ingestion.kafka.topic.pacs009:payments-pacs009}}"
              - simple: "${header.ExpectedMessageType} == 'pain.001'"
                steps:
                  - setHeader:
                      name: KafkaTopic
                      simple: "{{ingestion.kafka.topic.pain001:payments-pain001}}"
              - simple: "${header.ExpectedMessageType} == 'camt.053'"
                steps:
                  - setHeader:
                      name: KafkaTopic
                      simple: "{{ingestion.kafka.topic.camt053:payments-camt053}}"
            otherwise:
              steps:
                - setHeader:
                    name: KafkaTopic
                    simple: "{{ingestion.kafka.topic.default:payments-processed}}"
        - setHeader:
            name: kafka.KEY
            simple: "${header.PrimaryIdentifier:${exchangeId}}"
        # Add processing metadata to the message
        - script:
            groovy: |
              def originalBody = exchange.getIn().getBody(String.class)
              def enrichedMessage = """
              {
                  "metadata": {
                      "receiptChannel": "${exchange.getIn().getHeader('ReceiptChannel', 'UNKNOWN')}",
                      "receiptTimestamp": "${exchange.getIn().getHeader('ReceiptTimestamp', '')}",
                      "ingestionStartTime": "${exchange.getIn().getHeader('IngestionStartTime', '')}",
                      "publishTimestamp": "${exchange.getIn().getHeader('PublishTimestamp', '')}",
                      "primaryIdentifier": "${exchange.getIn().getHeader('PrimaryIdentifier', '')}",
                      "messageType": "${exchange.getIn().getHeader('ExpectedMessageType', 'UNKNOWN')}",
                      "validationPassed": ${exchange.getIn().getHeader('IsValid', false)},
                      "duplicateCheck": ${exchange.getIn().getHeader('IdempotenceChecked', false)},
                      "routingDestination": "kafka"
                  },
                  "payload": ${originalBody ?: 'null'}
              }
              """
              exchange.getIn().setBody(enrichedMessage)
        - toD:
            uri: "kafka:${header.KafkaTopic}?brokers={{ingestion.kafka.brokers:localhost:9092}}"
        - log:
            message: "Message successfully published to Kafka topic: ${header.KafkaTopic}"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "kafka-publisher"
        - setHeader:
            name: "LogCategory"
            constant: "BUSINESS"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Message successfully published to Kafka topic: ${header.KafkaTopic} for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"

# ===================================================================
# PROCESSING MODULE PUBLISHER - Real-time Route for HTTP/MQ Messages
# ===================================================================
# This route handles HTTP/MQ messages for real-time processing:
# - Routes directly to business module HTTP endpoints (bypasses Kafka)
# - Message-type-specific routing for optimal performance
# - Provides faster processing for interactive channels
- route:
    id: business-direct-publisher
    from:
      uri: direct:processing-publisher
      steps:
        - log:
            message: "[PROCESSING-ROUTE] Publishing message directly to business module"
        - setHeader:
            name: "LogLevel"
            constant: "INFO"
        - setHeader:
            name: "LogSource"
            constant: "processing-publisher"
        - setHeader:
            name: "LogCategory"
            constant: "ROUTE"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "[PROCESSING-ROUTE] Publishing message directly to business module for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: BUSINESS_MODULE_DIRECT
        - setHeader:
            name: PublishTimestamp
            simple: "${date:now:yyyy-MM-dd HH:mm:ss}"
        - setHeader:
            name: Content-Type
            constant: "application/json"
        # Route directly to business module based on message type
        - choice:
            when:
              - simple: "${header.ExpectedMessageType} == 'pacs.008'"
                steps:
                  - log:
                      message: "Routing PACS.008 message directly to business module"
                  - to:
                      uri: "http://localhost:8081/business/api/direct/pacs-008-transform?bridgeEndpoint=true&httpMethod=POST"
              - simple: "${header.ExpectedMessageType} == 'pacs.009'"
                steps:
                  - log:
                      message: "Routing PACS.009 message directly to business module"
                  - to:
                      uri: "http://localhost:8081/business/api/direct/pacs-009-transform?bridgeEndpoint=true&httpMethod=POST"
              - simple: "${header.ExpectedMessageType} == 'pain.001'"
                steps:
                  - log:
                      message: "Routing PAIN.001 message directly to business module"
                  - to:
                      uri: "http://localhost:8081/business/api/direct/pain-001-transform?bridgeEndpoint=true&httpMethod=POST"
              - simple: "${header.ExpectedMessageType} == 'camt.053'"
                steps:
                  - log:
                      message: "Routing CAMT.053 message directly to business module"
                  - to:
                      uri: "http://localhost:8081/business/api/direct/camt-053-transform?bridgeEndpoint=true&httpMethod=POST"
            otherwise:
              steps:
                - log:
                    message: "Unknown message type: ${header.ExpectedMessageType}, routing to business module general processor"
                - to:
                    uri: "http://localhost:8081/business/api/direct/kafka-message-processing?bridgeEndpoint=true&httpMethod=POST"
        - log:
            message: "Message successfully sent directly to business module"
        - setHeader:
            name: LogLevel
            constant: "INFO"
        - setHeader:
            name: LogSource
            constant: "BUSINESS_MODULE_DIRECT"
        - setHeader:
            name: LogCategory
            constant: "BUSINESS"
        - setHeader:
            name: CorrelationId
            simple: "${header.MessageId}"
        - setBody:
            simple: "Message successfully sent directly to business module for message ID: ${header.MessageId}"
        - to: kamelet:k-log-tx

# Rejection Handler
- route:
    id: rejection-handler
    from:
      uri: direct:rejection-handler
      steps:
        - log:
            message: "Processing rejected message: ${header.RejectionReason}"
        - setHeader:
            name: "LogLevel"
            constant: "WARN"
        - setHeader:
            name: "LogSource"
            constant: "rejection-handler"
        - setHeader:
            name: "LogCategory"
            constant: "ERROR"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Processing rejected message: ${header.RejectionReason} for message ID: ${header.MessageId}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: REJECTION
        - setHeader:
            name: RejectionTimestamp
            simple: "${date:now:yyyy-MM-dd HH:mm:ss}"
        # Create rejection message
        - script:
            groovy: |
              def rejectionMessage = """
              {
                  "rejectionInfo": {
                      "reason": "${exchange.getIn().getHeader('RejectionReason', 'UNKNOWN')}",
                      "timestamp": "${exchange.getIn().getHeader('RejectionTimestamp', '')}",
                      "receiptChannel": "${exchange.getIn().getHeader('ReceiptChannel', 'UNKNOWN')}",
                      "originalMessageId": "${exchange.getIn().getHeader('PrimaryIdentifier', '')}",
                      "errorDetails": "${exchange.getIn().getHeader('ValidationResult', '')}"
                  },
                  "originalMessage": ${exchange.getIn().getBody(String.class) ?: 'null'}
              }
              """
              exchange.getIn().setBody(rejectionMessage)
        - to:
            uri: "kafka:{{ingestion.kafka.topic.rejected:payments-rejected}}?brokers={{ingestion.kafka.brokers:localhost:9092}}"
        - log:
            message: "Rejected message sent to dead letter topic"
        - setHeader:
            name: LogLevel
            constant: "WARN"
        - setHeader:
            name: LogSource
            constant: "REJECTION_HANDLER"
        - setHeader:
            name: LogCategory
            constant: "BUSINESS"
        - setHeader:
            name: CorrelationId
            simple: "${header.MessageId}"
        - setBody:
            simple: "Rejected message sent to dead letter topic for message ID: ${header.MessageId}"
        - to: kamelet:k-log-tx

# Error Handler
- route:
    id: error-handler
    from:
      uri: direct:error-handler
      steps:
        - log:
            message: "Processing system error"
        - setHeader:
            name: "LogLevel"
            constant: "ERROR"
        - setHeader:
            name: "LogSource"
            constant: "error-handler"
        - setHeader:
            name: "LogCategory"
            constant: "ERROR"
        - setHeader:
            name: "CorrelationId"
            simple: "${header.MessageId}"
        - setBody:
            simple: "Processing system error for message ID: ${header.MessageId}, Error: ${exception.message}"
        - to: "kamelet:k-log-tx"
        - setHeader:
            name: ProcessingStage
            constant: ERROR
        # Create error message
        - script:
            groovy: |
              def errorMessage = """
              {
                  "errorInfo": {
                      "message": "${exchange.getIn().getHeader('ErrorMessage', 'Unknown error')}",
                      "timestamp": "${exchange.getIn().getHeader('ErrorTimestamp', '')}",
                      "receiptChannel": "${exchange.getIn().getHeader('ReceiptChannel', 'UNKNOWN')}",
                      "processingStage": "${exchange.getIn().getHeader('ProcessingStage', 'UNKNOWN')}"
                  },
                  "originalMessage": ${exchange.getIn().getBody(String.class) ?: 'null'}
              }
              """
              exchange.getIn().setBody(errorMessage)
        - to:
            uri: "kafka:{{ingestion.kafka.topic.errors:payments-errors}}?brokers={{ingestion.kafka.brokers:localhost:9092}}"
        - log:
            message: "Error message sent to error topic"
        - setHeader:
            name: LogLevel
            constant: "ERROR"
        - setHeader:
            name: LogSource
            constant: "ERROR_HANDLER"
        - setHeader:
            name: LogCategory
            constant: "ERROR"
        - setHeader:
            name: CorrelationId
            simple: "${header.MessageId}"
        - setBody:
            simple: "Error message sent to error topic for message ID: ${header.MessageId}"
        - to: kamelet:k-log-tx

# Health check endpoint
- route:
    id: health-check
    from:
      uri: platform-http:/health
    steps:
      - setBody:
          constant: '{"status":"UP","service":"payment-ingestion"}'
      - setHeader:
          name: Content-Type
          constant: "application/json"

# Metrics endpoint
- route:
    id: metrics-endpoint
    from:
      uri: platform-http:/metrics
    steps:
      - setBody:
          constant: '{"ingestionRoutes":{"active":true,"channels":["MQ_SERIES","REST_API","FILE_CFT"]}}'
      - setHeader:
          name: Content-Type
          constant: "application/json"

# Global error handler
- onException:
    exception:
      - java.lang.Exception
    handled: true
    steps:
      - log:
          message: "Error in payment ingestion: ${exception.message}"
      - setHeader:
          name: ErrorOccurred
          constant: true
      - setHeader:
          name: ErrorMessage
          simple: "${exception.message}"
      - setHeader:
          name: ErrorTimestamp
          simple: "${date:now:yyyy-MM-dd HH:mm:ss}"
      - to: direct:error-handler