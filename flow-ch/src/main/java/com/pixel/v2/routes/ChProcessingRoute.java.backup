package com.pixel.v2.routes;

import org.apache.camel.builder.RouteBuilder;
import org.springframework.stereotype.Component;

/**
 * CH Payment Processing Route
 * 
 * Main route for processing CH payment messages using k-kafka-starter kamelet
 * 
 * NOTE: This Java RouteBuilder uses k-mq-starter kamelet for CH processing
 */
@Component
public class ChProcessingRoute extends RouteBuilder {

        @Override
        public void configure() throws Exception {

                // Global exception handler for all errors including XSD validation
                onException(Exception.class).log(
                                "Global exception handler - Exception caught in CH processing: ${exception.message}")
                                .setHeader("ErrorType", simple("${exception.class.simpleName}"))
                                .setHeader("ErrorReason", simple("${exception.message}"))
                                .to("direct:error-handling").handled(true);


                // Error handler configuration
                errorHandler(defaultErrorHandler().maximumRedeliveries(0));

                // Main PACS008 processing route using k-mq-starter kamelet with sink functionality
                String kameletMqStarterEndpoint =
                                """
                                                kamelet:k-mq-starter?mqFileName={{kmq.starter.mqFileName}}&\
                                                connectionFactory={{kmq.starter.connectionFactory}}&\
                                                flowCode={{kmq.starter.flowCode}}&\
                                                messageType={{kmq.starter.messageType}}&\
                                                kafkaFlowSummaryTopicName={{kmq.starter.kafkaFlowSummaryTopicName}}&\
                                                kafkaLogTopicName={{kmq.starter.kafkaLogTopicName}}&\
                                                kafkaDistributionTopicName={{kmq.starter.kafkaDistributionTopicName}}&\
                                                brokers={{kmq.starter.brokers}}&\
                                                sinkEndpoint={{kmq.starter.sinkEndpoint}}&\
                                                flowCountryCode={{kmq.starter.flowCountryCode}}&\
                                                flowCountryId={{kmq.starter.flowCountryId}}&\
                                                dataSource={{kmq.starter.dataSource}}""";

                from(kameletMqStarterEndpoint).routeId("ch-processing-flow").log(
                                "K-MQ-Starter kamelet initiated - message will be processed and sent to sink")
                                .end();

                // Sink endpoint to receive messages from k-mq-starter kamelet
                from("{{kmq.starter.sinkEndpoint}}").routeId("ch-main-processing")
                                .setHeader("MessageType", constant("PACS008"))
                                .setHeader("ProcessingTimestamp",
                                                simple("${date:now:yyyy-MM-dd'T'HH:mm:ss.SSSZ}"))
                                .to("direct:process-ch-message");

                // CH processing logic
                from("direct:process-ch-message").routeId("ch-message-processing")
                                // Enrich message with metadata
                                .setHeader("RouteName", constant("CH-Processing"))
                                .setHeader("ProcessingNode", simple("${sys.HOSTNAME}"))

                                .doTry()
                                // Step 1: Get flow configuration from Redis cache
                                .log("Getting flow configuration from Redis for flow code: {{kmq.starter.flowCode}}")
                                .setHeader("OriginalBody", simple("${body}"))
                                .setHeader("RedisKey",
                                                simple("flow:{{kmq.starter.flowCode}}:complete"))
                                .setHeader("CamelRedisOperation", constant("GET"))
                                .setHeader("CamelRedisKey", simple("${header.RedisKey}"))
                                .to("spring-redis://{{redis.host}}:{{redis.port}}?database={{redis.database}}")
                                .choice().when(simple("${body} != null"))
                                .log("Flow configuration found in Redis cache - Key: ${header.RedisKey}")
                                .setHeader("FlowConfiguration", simple("${body}")).otherwise()
                                .log("Flow configuration not found in cache, calling referentiel service for: {{kmq.starter.flowCode}}")
                                .setHeader("CamelHttpMethod", constant("GET"))
                                .setHeader("Content-Type", constant("application/json"))
                                .to("{{referentiel.service.url}}/api/flows/{{kmq.starter.flowCode}}/complete?bridgeEndpoint=true")
                                .convertBodyTo(String.class)
                                .setHeader("FlowConfiguration", simple("${body}"))
                                .log("Caching flow configuration in Redis - Key: ${header.RedisKey}")
                                .setHeader("CamelRedisOperation", constant("SET"))
                                .setHeader("CamelRedisKey", simple("${header.RedisKey}"))
                                .setHeader("CamelRedisValue", simple("${body}"))
                                .setHeader("CamelRedisTimeout", constant("3600")) // 1 hour TTL
                                .to("spring-redis://{{redis.host}}:{{redis.port}}?database={{redis.database}}")
                                .end().setBody(simple("${header.OriginalBody}"))
                                .removeHeader("OriginalBody").removeHeader("RedisKey")
                                .log("Flow configuration ready from cache: ${header.FlowConfiguration.substring(0, 100)}...")

                                // Step 2: XSD Validation using k-xsd-validation
                                .to("kamelet:k-xsd-validation?xsdFileName=pacs.008.001.02.ch.02.xsd&validationMode=STRICT")
                                // Step 3: XSLT Transformation using k-xsl-transformation
                                .to("kamelet:k-xsl-transformation?xslFileName=overall-xslt-ch-pacs008-001-02.xsl&transformationMode=STRICT")
                                .doCatch(Exception.class)
                                .log("Error in processing: ${exception.message}")
                                .to("direct:error-handling").end()
                                // Log completion to flow summary after successful processing
                                .wireTap("kamelet:k-log-flow-summary?step=COMPLETED&kafkaTopicName=${header.kafkaFlowSummaryTopicName}&brokers=${header.brokers}");

                // Redis Cache Refresh Route - listens to ch-refresh topic
                from("kafka:ch-refresh?brokers={{kmq.starter.brokers}}&groupId=ch-cache-refresh&offsetReset=latest")
                                .routeId("ch-cache-refresh")
                                .log("Received cache refresh event: ${body}").unmarshal().json()
                                .choice().when(jsonpath("$.action[?(@ == 'REFRESH_FLOW')]"))
                                .setHeader("FlowCode", jsonpath("$.flowCode"))
                                .setHeader("RedisKey", simple("flow:${header.FlowCode}:complete"))
                                .log("Refreshing cache for flow: ${header.FlowCode}")
                                // Delete existing cache entry
                                .setHeader("CamelRedisOperation", constant("DEL"))
                                .setHeader("CamelRedisKey", simple("${header.RedisKey}"))
                                .to("spring-redis://{{redis.host}}:{{redis.port}}?database={{redis.database}}")
                                // Fetch fresh data from referentiel
                                .setHeader("CamelHttpMethod", constant("GET"))
                                .setHeader("Content-Type", constant("application/json"))
                                .toD("{{referentiel.service.url}}/api/flows/${header.FlowCode}/complete?bridgeEndpoint=true")
                                .convertBodyTo(String.class)
                                // Cache the fresh data
                                .setHeader("CamelRedisOperation", constant("SET"))
                                .setHeader("CamelRedisKey", simple("${header.RedisKey}"))
                                .setHeader("CamelRedisValue", simple("${body}"))
                                .setHeader("CamelRedisTimeout", constant("3600")) // 1 hour TTL
                                .to("spring-redis://{{redis.host}}:{{redis.port}}?database={{redis.database}}")
                                .log("Cache refreshed for flow: ${header.FlowCode} - Data length: ${body.length()}")
                                .when(jsonpath("$.action[?(@ == 'CLEAR_ALL_CACHE')]"))
                                .log("Clearing all flow cache entries")
                                .setHeader("CamelRedisOperation", constant("FLUSHDB"))
                                .to("spring-redis://{{redis.host}}:{{redis.port}}?database={{redis.database}}")
                                .log("All cache entries cleared").otherwise()
                                .log("Unknown refresh action: ${body}").end();

        }
}
